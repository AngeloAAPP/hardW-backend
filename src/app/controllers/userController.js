const User = require('../../database/models/User')
const {generateToken, generateRefreshToken} = require('../helpers/tokens')
const {encode} = require('../helpers/hashids')
const {client: Cache, setCache} = require('../helpers/redis')
const {cloudinary} = require('../../config/cloudinary')
const path = require('path')
const fs = require('fs')
const bcrypt = require('bcrypt')
const DBconnection = require('../../database')

function dropTemporaryImage(image){
    fs.unlink(path.resolve(__dirname, '..', '..', '..', 'temp', image), (err) => {
        if(err)
             console.log("Falha ao deletar arquivo")
    })
}

module.exports = {
    //create user
    create: async(req,res) => {
        const {name, lastName, whatsapp, email, password, zipCode, street, neighbourhood, uf, city} = req.body;
        let image, avatarUrl, imagePublicID = null

        try {
            image = req.file.filename
        } catch (err) {}

        try{

            const result = await DBconnection.transaction(async transaction => {
                if(image){
                    //upload image
                    const {secure_url, public_id} = await cloudinary.uploader.upload(path.resolve(__dirname, '..', '..', '..', 'temp', image), {
                        folder: 'profiles',
                    })
                    
                    avatarUrl = secure_url
                    imagePublicID = public_id
                 }
     
                 const user = await User.create({
                     name,
                     lastName,
                     whatsapp,
                     avatarUrl,
                     imagePublicID,
                     email,
                     password
                 }, {transaction})
                 
                 //omit password and image ID in return data
                 user.password = undefined
                 user.imagePublicID = undefined

                 //create address
                 const address = await user.createAddress({
                    zipCode,
                    street,
                    neighbourhood,
                    uf,
                    city,
                }, {transaction})

                address.userID = undefined

                return {user: {...user.dataValues, id: encode(user.id)}, address: {...address.dataValues, id: encode(address.id)}}

            })


            const refreshToken = generateRefreshToken()

            res.setHeader('Authorization', 'Bearer ' + generateToken({user: encode(result.user.id)}, 300))
            res.setHeader('Refresh', refreshToken)

            await setCache(Cache, refreshToken, encode(result.user.id), 2592000)
            
            if(image)
                dropTemporaryImage(image)

            return res.status(201).json(result)
        }
        catch(err){
            if(image){
                dropTemporaryImage(image)
                try {
                    await cloudinary.uploader.destroy(imagePublicID)
                } catch (err) {}
            }

            //get the error message generated by the sequelize validation
            try{
                let error = err.errors[0].message;
                return res.status(400).json({success: false, error})
            }
            //if the error message was generated by the throw new Error command
            catch(e){
                return res.status(400).json({success: false, message: err.toString()})
            }   
        }
    },
    //update user
    update: async(req,res) => {

        const {name, lastName, whatsapp, city, neighbourhood, uf, street, zipCode} = req.body

        const user = await User.findByPk(req.user)

        if(!user)
            return res.status(400).json({
                success: false,
                message: "Usuário não encontrado"
            })

        try {

            const result = await DBconnection.transaction(async transaction => {
                const address = await user.getAddress({transaction})

                await user.update({name, lastName, whatsapp},{transaction})
                await address.update({city, neighbourhood, uf, street, zipCode},{transaction})

                return {success: true}
            })
           
           return res.json(result)
        } catch (err) {
            try{
                let error = err.errors[0].message;
                return res.status(400).json({success: false, error})
            }
            //if the error message was generated by the throw new Error command
            catch(e){
                return res.status(400).json({success: false, message: err.toString()})
            }   
        }
    },
    //change user profile photo
    changeAvatarUrl: async(req,res) => {

        let image = null

        try {

            const user = await User.findByPk(req.user, {attributes: ['id', 'avatarUrl', 'imagePublicID']})

            if(!user)
                return res.status(400).json({
                    success: false,
                    message: "Usuário não encontrado"
                })

            try {
                image = req.file.filename
            } catch (err) {}

            //deletes the current image from the cloudinary server
            if(user.avatarUrl !== null)
                await cloudinary.uploader.destroy(user.imagePublicID)

            if(image === null){

                user.avatarUrl = null
                user.imagePublicID = null
            }
            else{
                //upload image
                const {secure_url, public_id} = await cloudinary.uploader.upload(path.resolve(__dirname, '..', '..', '..', 'temp', image), {
                    folder: 'profiles',
                })
                
                user.avatarUrl = secure_url
                user.imagePublicID = public_id
            }

            if(image !== null)
                dropTemporaryImage(image)

            await user.save()
            return res.json({ success : true})
            
        } catch (err) {

            if(image !== null)
                dropTemporaryImage(image)

            return res.status(500).json({
                success: false,
                message: "Erro no servidor. Tente novamente"
            })
        }
    },
    //change user password
    changePassword: async(req,res) => {

        const {password, currentPassword} = req.body


        try {
            if(!password || !currentPassword)
                return res.status(400).json({
                    success: false,
                    message: "Parâmetros ausentes"
                })

            const user = await User.findByPk(req.user, { attributes: ['id', 'password']})

            if(!user)
                return res.status(400).json({
                    success: false,
                    message: "Usuário não encontrado"
                })
            
            if(! await bcrypt.compare(currentPassword, user.password))
                return res.status(400).json({
                    success: false,
                    message: "Senha incorreta"
                })
            
            if(password.length < 5 || password.length > 20)
                return res.status(400).json({
                    success: false,
                    message: "A senha deve conter entre 5 e 20 caracteres"
                })
            
            user.password = await bcrypt.hash(password, 10)
            await user.save()

            return res.json({success: true})
            
        } catch (err) {
            return res.status(500).json({
                success: false,
                message: "Erro no servidor. Tente novamente"
            })
        }


    },
    //delete user
    destroy: async(req,res) => {
        
        try {
            const user = await User.findByPk(req.user, {
                attributes: ['id', 'avatarUrl', 'imagePublicID'],
                include: {
                    association: 'adverts',
                    attributes: ['id'],
                    include: {
                        association: 'images',
                        attributes: ['id', 'publicID']
                    }
                }
            })


            if(!user)
                return res.status(400).json({
                    success: false,
                    message: "Usuário não encontrado"
                })

            //deletes the profile photo of the cloudinary server
            if(user.avatarUrl)
                await cloudinary.uploader.destroy(user.imagePublicID)

            const advertsImages = user.dataValues.adverts.map(advertisement => advertisement.images[0])

            //deletes images from user adverts on the cloudinary server
            for (const image of advertsImages) {
                if(image)
                    {
                        try {
                            await cloudinary.uploader.destroy(image.publicID)
                        } catch (err) {}
                    }
            }

            await user.destroy()
            await user.save()

            return res.json({ success: true })
        } catch (err) {
            console.log(err)
            return res.status(500).json({success: false, message: "Erro no servidor. Tente novamente"})
        }
    }
}