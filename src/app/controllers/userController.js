const User = require('../../database/models/User')
const {generateToken, generateRefreshToken} = require('../helpers/tokens')
const {encode, decode} = require('../helpers/hashids')
const {client: Cache, setCache} = require('../helpers/redis')
const {cloudinary} = require('../../config/cloudinary')
const path = require('path')
const fs = require('fs')
const bcrypt = require('bcrypt')

function dropTemporaryImage(image){
    fs.unlink(path.resolve(__dirname, '..', '..', '..', 'temp', image), (err) => {
        if(err)
             console.log("Falha ao deletar arquivo")
    })
}

module.exports = {
    create: async(req,res) => {
        const {name, lastName, whatsapp, email, password} = req.body;
        let image, avatarUrl, imagePublicID = null

        try {
            image = req.file.filename
        } catch (err) {}

        try{

            if(image){
               const {secure_url, public_id} = await cloudinary.uploader.upload(path.resolve(__dirname, '..', '..', '..', 'temp', image), {
                   folder: 'profiles',
               })
               
               avatarUrl = secure_url
               imagePublicID = public_id
            }

            const user = await User.create({
                name,
                lastName,
                whatsapp,
                avatarUrl,
                imagePublicID,
                email,
                password
            })
            
            //omit password and image ID in return data
            user.password = undefined
            user.imagePublicID = undefined

            const refreshToken = generateRefreshToken()

            res.setHeader('Authorization', 'Bearer ' + generateToken({user: encode(user.id)}, 300))
            res.setHeader('Refresh', refreshToken)

            await setCache(Cache, refreshToken, encode(user.id), 2592000)
            
            if(image)
                dropTemporaryImage(image)

            return res.status(201).json({...user.dataValues, id: encode(user.id), })
        }
        catch(err){
            if(image){
                dropTemporaryImage(image)
                try {
                    await cloudinary.uploader.destroy(imagePublicID)
                } catch (err) {}
            }

            //get the error message generated by the sequelize validation
            try{
                let error = err.errors[0].message;
                return res.status(400).json({success: false, error})
            }
            //if the error message was generated by the throw new Error command
            catch(e){
                return res.status(400).json({success: false, message: err.toString()})
            }   
        }
    },
    update: async(req,res) => {

        const {userID} = req.params

        if(decode(userID) !== req.user)
    
            return res.status(403).json({
                success: false,
                message: "Acesso negado"
            })

        const {name, lastName, whatsapp} = req.body

        const user = await User.findByPk(req.user)

        if(!user)
            return res.status(400).json({
                success: false,
                message: "Usuário não encontrado"
            })

        try {
           await user.update({name, lastName, whatsapp})
           return res.json({success: true})
        } catch (err) {
            try{
                let error = err.errors[0].message;
                return res.status(400).json({success: false, error})
            }
            //if the error message was generated by the throw new Error command
            catch(e){
                return res.status(400).json({success: false, message: err.toString()})
            }   
        }
    },
    changeAvatarUrl: async(req,res) => {
        const {userID} = req.params

        if(decode(userID) !== req.user)
    
            return res.status(403).json({
                success: false,
                message: "Acesso negado"
            })

        let image = null

        try {

            const user = await User.findByPk(req.user, {attributes: ['id', 'avatarUrl', 'imagePublicID']})

            if(!user)
                return res.status(400).json({
                    success: false,
                    message: "Usuário não encontrado"
                })

            try {
                image = req.file.filename
            } catch (err) {}

            if(user.avatarUrl !== null)
                await cloudinary.uploader.destroy(user.imagePublicID)

            if(image === null){

                user.avatarUrl = null
                user.imagePublicID = null
            }
            else{
                const {secure_url, public_id} = await cloudinary.uploader.upload(path.resolve(__dirname, '..', '..', '..', 'temp', image), {
                    folder: 'profiles',
                })
                
                user.avatarUrl = secure_url
                user.imagePublicID = public_id
            }

            if(image !== null)
                dropTemporaryImage(image)

            await user.save()
            return res.json({ success : true})
            
        } catch (err) {

            if(image !== null)
                dropTemporaryImage(image)

            return res.status(500).json({
                success: false,
                message: "Erro no servidor. Tente novamente"
            })
        }
    },
    changePassword: async(req,res) => {

        const {userID} = req.params
        const {password, currentPassword} = req.body

        if(decode(userID) !== req.user)
            return res.status(403).json({
                success: false,
                message: "Acesso negado"
            })

        try {
            if(!password || !currentPassword)
                return res.status(400).json({
                    success: false,
                    message: "Parâmetros ausentes"
                })

            const user = await User.findByPk(req.user, { attributes: ['id', 'password']})

            if(!user)
                return res.status(400).json({
                    success: false,
                    message: "Usuário não encontrado"
                })
            
            if(! await bcrypt.compare(currentPassword, user.password))
                return res.status(400).json({
                    success: false,
                    message: "Senha incorreta"
                })
            
            if(password.length < 5 || password.length > 20)
                return res.status(400).json({
                    success: false,
                    message: "A senha deve conter entre 5 e 20 caracteres"
                })
            
            user.password = await bcrypt.hash(password, 10)
            await user.save()

            return res.json({success: true})
            
        } catch (err) {
            return res.status(500).json({
                success: false,
                message: "Erro no servidor. Tente novamente"
            })
        }


    },
    destroy: async(req,res) => {

        const {userID} = req.params

        if(decode(userID) !== req.user)
    
            return res.status(403).json({
                success: false,
                message: "Acesso negado"
            })
        
        try {
            const user = await User.findByPk(req.user, {attributes: ['id', 'avatarURL', 'imagePublicID']})

            if(!user)
                return res.status(400).json({
                    success: false,
                    message: "Usuário não encontrado"
                })

            if(user.avatarURL)
                await cloudinary.uploader.destroy(user.imagePublicID)

            await user.destroy()
            await user.save()

            return res.json({ success: true })
        } catch (err) {
            return res.status(500).json({success: false, message: "Erro no servidor. Tente novamente"})
        }
    }
}