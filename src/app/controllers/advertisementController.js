const Advertisement = require('../../database/models/Advertisement')
const fs = require('fs')
const {cloudinary} = require('../../config/cloudinary')
const DBconnection = require('../../database')
const {encode, decode} = require('../helpers/hashids')
const path = require('path')
const AdvertImage = require('../../database/models/AdvertImage')

function dropTemporaryImages(images){
    images.forEach(image => {
        fs.unlink(path.resolve(__dirname, '..', '..', '..', 'temp', image.filename), (err) => {
            if(err)
                 console.log("Falha ao deletar arquivo")
        })
    });
}

module.exports = {
    create: async(req,res) => {

        let uploadedImages = []
        let images = []

        try {
            const result = await DBconnection.transaction(async transaction => {

                const {name, price, description, categoryID, subcategoryID} = req.body
                const advertisement = await Advertisement.create({name, price, description, categoryID, subcategoryID, userID: req.user}, {transaction})

                try {
                    if(req.files.length > 0){
                        for (const image of req.files) {
                            const {secure_url, public_id} = await cloudinary.uploader.upload(path.resolve(__dirname, '..', '..', '..', 'temp', image.filename), {
                                folder: 'adverts'
                            })
                            uploadedImages.push({secure_url, public_id})
                        }
                    }
                } catch (err) {
                    throw new Error("Falha ao realizar upload de imagens")
                }

                if(uploadedImages.length > 0)
                {
                    for (const image of uploadedImages) {
                        const advertImage = await AdvertImage.create({
                            url: image.secure_url, 
                            publicID: image.public_id,
                            advertisementID: advertisement.id
                        }, {transaction})

                        images.push(advertImage)
                    }
                }

                if(images.length > 0)
                {
                    const serializedImages = images.map(image => (
                        {
                            url: image.dataValues.url
                        }
                    ))
                    images = serializedImages
                }

                return {
                        ...advertisement.dataValues, 
                        id: encode(advertisement.id), 
                        userID: encode(advertisement.userID),
                        images
                }

            })

            dropTemporaryImages(req.files)
            return res.status(201).json(result)
            
        } catch (err) {

            dropTemporaryImages(req.files)

            if(uploadedImages.length > 0)
            {
                for (const image of uploadedImages) {
                    try {
                        await cloudinary.uploader.destroy(image.public_id)
                    } catch (error) {
                    }
                    
                }
            }

            try{
                let error = err.errors[0].message;
                return res.status(400).json({success: false, error})
            }
            //if the error message was generated by the throw new Error command
            catch(e){
                return res.status(400).json({success: false, message: err.toString()})
            }   
        }

    },
    destroy: async(req,res) => {
        const {advertisementID} = req.body

        if(!advertisementID)
            return res.status(400).json({
                success: false,
                message: "ID do anúncio é obrigatório"
            })
        
        try {
            const advertisement = await Advertisement.findByPk(decode(advertisementID), {
                attributes: ['id'],
                include: {
                    association: 'images',
                    attributes: ['id', 'publicID']
                }
            })

            for (const image of advertisement.dataValues.images) {
                try {
                    await cloudinary.uploader.destroy(image.publicID)
                } catch (err) {}
            }

            await advertisement.destroy()
            await advertisement.save()

            return res.json({ success : true})
        } catch (err) {
            return res.status(500).json({success: false, message: "Erro no servidor. Tente novamente"})
        }
    }
}